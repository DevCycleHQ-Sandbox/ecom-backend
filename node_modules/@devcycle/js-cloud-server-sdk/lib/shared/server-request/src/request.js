"use strict";
// NOTE: This file is duplicated in "sdk/js/src/RequestUtils" because nx:rollup cant build non-external dependencies
// from outside the root directory https://github.com/nrwl/nx/issues/10395
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exponentialBackoff = exports.ResponseError = void 0;
exports.handleResponse = handleResponse;
exports.getWithTimeout = getWithTimeout;
exports.post = post;
exports.patch = patch;
exports.get = get;
const fetch_retry_1 = __importDefault(require("fetch-retry"));
class ResponseError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ResponseError';
    }
}
exports.ResponseError = ResponseError;
const exponentialBackoff = (attempt) => {
    const delay = Math.pow(2, attempt) * 100;
    const randomSum = delay * 0.2 * Math.random();
    return delay + randomSum;
};
exports.exponentialBackoff = exponentialBackoff;
const retryOnRequestError = (retries) => {
    return (attempt, error, response) => {
        if (attempt >= retries) {
            return false;
        }
        else if (response && (response === null || response === void 0 ? void 0 : response.status) < 500) {
            return false;
        }
        return true;
    };
};
async function handleResponse(res) {
    // res.ok only checks for 200-299 status codes
    if (!res.ok && res.status >= 400) {
        let error;
        try {
            const response = await res.clone().json();
            error = new ResponseError(response.message || 'Something went wrong');
        }
        catch (e) {
            error = new ResponseError('Something went wrong');
        }
        error.status = res.status;
        throw error;
    }
    return res;
}
async function getWithTimeout(url, requestConfig, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => {
        controller.abort();
    }, timeout);
    const response = await get(url, {
        ...requestConfig,
        signal: controller.signal,
    });
    clearTimeout(id);
    return response;
}
async function post(url, requestConfig, sdkKey) {
    const [_fetch, config] = await getFetchAndConfig(requestConfig);
    const postHeaders = {
        ...config.headers,
        Authorization: sdkKey,
        'Content-Type': 'application/json',
    };
    const res = await _fetch(url, {
        ...config,
        headers: postHeaders,
        method: 'POST',
    });
    return handleResponse(res);
}
async function patch(url, requestConfig, sdkKey) {
    const [_fetch, config] = await getFetchAndConfig(requestConfig);
    const patchHeaders = {
        ...config.headers,
        Authorization: sdkKey,
        'Content-Type': 'application/json',
    };
    const res = await _fetch(url, {
        ...config,
        headers: patchHeaders,
        method: 'PATCH',
    });
    return handleResponse(res);
}
async function get(url, requestConfig) {
    const [_fetch, config] = await getFetchAndConfig(requestConfig);
    const headers = { ...config.headers, 'Content-Type': 'application/json' };
    const res = await _fetch(url, {
        ...config,
        headers,
        method: 'GET',
    });
    return handleResponse(res);
}
async function getFetch() {
    if (typeof fetch !== 'undefined') {
        return fetch;
    }
    return (await import('cross-fetch')).default;
}
async function getFetchWithRetry() {
    const fetch = await getFetch();
    return (0, fetch_retry_1.default)(fetch);
}
async function getFetchAndConfig(requestConfig) {
    const useRetries = 'retries' in requestConfig;
    if (useRetries && requestConfig.retries) {
        const newConfig = { ...requestConfig };
        newConfig.retryOn =
            newConfig.retryOn || retryOnRequestError(requestConfig.retries);
        newConfig.retryDelay = exports.exponentialBackoff;
        return [await getFetchWithRetry(), newConfig];
    }
    return [await getFetch(), requestConfig];
}
//# sourceMappingURL=request.js.map