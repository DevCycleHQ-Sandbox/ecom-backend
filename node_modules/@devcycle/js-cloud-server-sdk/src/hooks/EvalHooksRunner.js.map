{"version":3,"file":"EvalHooksRunner.js","sourceRoot":"","sources":["../../../../../../../sdk/js-cloud-server/src/hooks/EvalHooksRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import { DevCycleUser, DVCVariable } from '../../src/'\nimport { EvalHook } from './EvalHook'\nimport { HookContext } from './HookContext'\nimport { DVCLogger } from '@devcycle/types'\nimport { VariableValue as DVCVariableValue } from '@devcycle/types'\n\nexport class EvalHooksRunner {\n    constructor(\n        private hooks: EvalHook[] = [],\n        private readonly logger?: DVCLogger,\n    ) {}\n\n    async runHooksForEvaluation<T extends DVCVariableValue>(\n        user: DevCycleUser,\n        key: string,\n        defaultValue: T,\n        resolver: (context: HookContext<T>) => Promise<DVCVariable<T>>,\n    ): Promise<DVCVariable<T>> {\n        const context = new HookContext<T>(user, key, defaultValue, {})\n        const savedHooks = [...this.hooks]\n        const reversedHooks = [...savedHooks].reverse()\n\n        let beforeContext = context\n        let variableDetails: DVCVariable<T>\n        try {\n            beforeContext = await this.runBefore(savedHooks, context)\n            variableDetails = await resolver(beforeContext)\n            await this.runAfter(reversedHooks, beforeContext, variableDetails)\n        } catch (error) {\n            await this.runError(reversedHooks, context, error)\n            await this.runFinally(reversedHooks, context, undefined)\n            if (\n                error.name === 'BeforeHookError' ||\n                error.name === 'AfterHookError'\n            ) {\n                // make sure to return with a variable if before or after hook errors\n                return await resolver(context)\n            }\n            throw error\n        }\n        await this.runFinally(reversedHooks, context, variableDetails)\n        return variableDetails\n    }\n\n    private async runBefore<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n    ): Promise<HookContext<T>> {\n        const contextCopy = { ...context }\n        try {\n            for (const hook of hooks) {\n                const newContext = await hook.before(contextCopy)\n                if (newContext) {\n                    Object.assign(contextCopy, {\n                        ...contextCopy,\n                        ...newContext,\n                    })\n                }\n            }\n        } catch (error) {\n            this.logger?.error('Error running before hooks', error)\n            throw new BeforeHookError(error)\n        }\n        return contextCopy\n    }\n\n    private async runAfter<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n        variableDetails: DVCVariable<T>,\n    ): Promise<void> {\n        try {\n            for (const hook of hooks) {\n                await hook.after(context, variableDetails)\n            }\n        } catch (error) {\n            this.logger?.error('Error running after hooks', error)\n            throw new AfterHookError(error)\n        }\n    }\n\n    private async runFinally<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n        variableDetails: DVCVariable<T> | undefined,\n    ): Promise<void> {\n        try {\n            for (const hook of hooks) {\n                await hook.onFinally(context, variableDetails)\n            }\n        } catch (error) {\n            this.logger?.error('Error running finally hooks', error)\n        }\n    }\n\n    private async runError<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n        error: Error,\n    ): Promise<void> {\n        try {\n            for (const hook of hooks) {\n                await hook.error(context, error)\n            }\n        } catch (error) {\n            this.logger?.error('Error running error hooks', error)\n        }\n    }\n\n    enqueue(hook: EvalHook): void {\n        this.hooks.push(hook)\n    }\n\n    clear(): void {\n        this.hooks = []\n    }\n}\n\nclass BeforeHookError extends Error {\n    constructor(error: Error) {\n        super(error.message)\n        this.name = 'BeforeHookError'\n        this.stack = error.stack\n    }\n}\n\nclass AfterHookError extends Error {\n    constructor(error: Error) {\n        super(error.message)\n        this.name = 'AfterHookError'\n        this.stack = error.stack\n    }\n}\n"]}