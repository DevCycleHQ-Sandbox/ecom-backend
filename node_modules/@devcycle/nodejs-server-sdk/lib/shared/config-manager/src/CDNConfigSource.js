"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CDNConfigSource = void 0;
const types_1 = require("@devcycle/types");
const request_1 = require("./request");
const server_request_1 = require("../../../../server-request/src");
class CDNConfigSource extends types_1.ConfigSource {
    constructor(cdnURI, logger, requestTimeoutMS) {
        super();
        this.cdnURI = cdnURI;
        this.logger = logger;
        this.requestTimeoutMS = requestTimeoutMS;
    }
    // type generic to make typescript happy. It's always false in this implementation
    async getConfig(sdkKey, kind, obfuscated, lastModifiedThreshold) {
        var _a, _b, _c, _d;
        let res;
        try {
            res = await (0, request_1.getEnvironmentConfig)({
                logger: this.logger,
                url: this.getConfigURL(sdkKey, kind),
                requestTimeout: this.requestTimeoutMS,
                currentEtag: this.configEtag,
                currentLastModified: this.configLastModified,
                sseLastModified: lastModifiedThreshold,
            });
        }
        catch (e) {
            if (e instanceof server_request_1.ResponseError && e.status === 403) {
                throw new types_1.UserError(`Invalid SDK key provided: ${sdkKey}`);
            }
            throw e;
        }
        const metadata = {
            resEtag: (_a = res.headers.get('etag')) !== null && _a !== void 0 ? _a : undefined,
            resLastModified: (_b = res.headers.get('last-modified')) !== null && _b !== void 0 ? _b : undefined,
            resRayId: (_c = res.headers.get('cf-ray')) !== null && _c !== void 0 ? _c : undefined,
            resStatus: (_d = res.status) !== null && _d !== void 0 ? _d : undefined,
        };
        res.headers.forEach((value, name) => {
            metadata[`resHeader_` + name] = value;
        });
        this.logger.debug(`Downloaded config, status: ${res === null || res === void 0 ? void 0 : res.status}, etag: ${res === null || res === void 0 ? void 0 : res.headers.get('etag')}`);
        if (res.status === 304) {
            this.logger.debug(`Config not modified, using cache, etag: ${this.configEtag}` +
                `, last-modified: ${this.configLastModified}`);
        }
        else if (res.status === 200) {
            const projectConfig = (await res.json());
            const lastModifiedHeader = res.headers.get('last-modified');
            if (this.isLastModifiedHeaderOld(lastModifiedHeader !== null && lastModifiedHeader !== void 0 ? lastModifiedHeader : null)) {
                this.logger.debug('Skipping saving config, existing last modified date is newer.');
                return {
                    config: null,
                    metaData: metadata,
                    lastModified: lastModifiedHeader,
                };
            }
            this.configEtag = res.headers.get('etag') || '';
            this.configLastModified = lastModifiedHeader || '';
            return {
                config: projectConfig,
                metaData: metadata,
                lastModified: lastModifiedHeader,
            };
        }
        return {
            config: null,
            metaData: metadata,
            lastModified: null,
        };
    }
    getConfigURL(sdkKey, kind) {
        if (kind === 'bootstrap') {
            return `${this.cdnURI}/config/v2/server/bootstrap/${sdkKey}.json`;
        }
        return `${this.cdnURI}/config/v2/server/${sdkKey}.json`;
    }
}
exports.CDNConfigSource = CDNConfigSource;
//# sourceMappingURL=CDNConfigSource.js.map