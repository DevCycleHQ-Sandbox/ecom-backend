"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvalHooksRunner = void 0;
const HookContext_1 = require("./HookContext");
class EvalHooksRunner {
    constructor(hooks = [], logger) {
        this.hooks = hooks;
        this.logger = logger;
    }
    runHooksForEvaluation(user, key, defaultValue, resolver) {
        const context = new HookContext_1.HookContext(user, key, defaultValue, {});
        const savedHooks = [...this.hooks];
        const reversedHooks = [...savedHooks].reverse();
        let beforeContext = context;
        let variableDetails;
        try {
            beforeContext = this.runBefore(savedHooks, context);
            variableDetails = resolver.call(beforeContext);
            this.runAfter(savedHooks, beforeContext, variableDetails);
        }
        catch (error) {
            this.runError(reversedHooks, context, error);
            this.runFinally(reversedHooks, context, undefined);
            if (error.name === 'BeforeHookError' ||
                error.name === 'AfterHookError') {
                // make sure to return with a variable if before or after hook errors
                return resolver.call(context);
            }
            throw error;
        }
        this.runFinally(reversedHooks, context, variableDetails);
        return variableDetails;
    }
    runBefore(hooks, context) {
        var _a;
        const contextCopy = { ...context };
        try {
            for (const hook of hooks) {
                const newContext = hook.before(contextCopy);
                if (newContext) {
                    Object.assign(contextCopy, {
                        ...contextCopy,
                        ...newContext,
                    });
                }
            }
        }
        catch (error) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Error running before hooks', error);
            throw new BeforeHookError(error);
        }
        return contextCopy;
    }
    runAfter(hooks, context, variableDetails) {
        var _a;
        try {
            for (const hook of hooks) {
                hook.after(context, variableDetails);
            }
        }
        catch (error) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Error running after hooks', error);
            throw new AfterHookError(error);
        }
    }
    runFinally(hooks, context, variableDetails) {
        var _a;
        try {
            for (const hook of hooks) {
                hook.onFinally(context, variableDetails);
            }
        }
        catch (error) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Error running finally hooks', error);
        }
    }
    runError(hooks, context, error) {
        var _a;
        try {
            for (const hook of hooks) {
                hook.error(context, error);
            }
        }
        catch (error) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Error running error hooks', error);
        }
    }
    enqueue(hook) {
        this.hooks.push(hook);
    }
}
exports.EvalHooksRunner = EvalHooksRunner;
class HooksRunnerError extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'HooksRunnerError';
        this.stack = error.stack;
    }
}
class BeforeHookError extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'BeforeHookError';
        this.stack = error.stack;
    }
}
class AfterHookError extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'AfterHookError';
        this.stack = error.stack;
    }
}
//# sourceMappingURL=EvalHooksRunner.js.map