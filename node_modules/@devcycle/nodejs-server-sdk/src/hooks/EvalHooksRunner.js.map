{"version":3,"file":"EvalHooksRunner.js","sourceRoot":"","sources":["../../../../../../../sdk/nodejs/src/hooks/EvalHooksRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import { DevCycleUser, DVCVariable } from '../../src/'\nimport { EvalHook } from './EvalHook'\nimport { HookContext } from './HookContext'\nimport { DVCLogger } from '@devcycle/types'\nimport { VariableValue as DVCVariableValue } from '@devcycle/types'\n\nexport class EvalHooksRunner {\n    constructor(\n        private readonly hooks: EvalHook[] = [],\n        private readonly logger?: DVCLogger,\n    ) {}\n\n    runHooksForEvaluation<T extends DVCVariableValue>(\n        user: DevCycleUser,\n        key: string,\n        defaultValue: T,\n        resolver: (context: HookContext<T>) => DVCVariable<T>,\n    ): DVCVariable<T> {\n        const context = new HookContext<T>(user, key, defaultValue, {})\n        const savedHooks = [...this.hooks]\n        const reversedHooks = [...savedHooks].reverse()\n\n        let beforeContext = context\n        let variableDetails: DVCVariable<T>\n        try {\n            beforeContext = this.runBefore(savedHooks, context)\n            variableDetails = resolver.call(beforeContext)\n            this.runAfter(savedHooks, beforeContext, variableDetails)\n        } catch (error) {\n            this.runError(reversedHooks, context, error)\n            this.runFinally(reversedHooks, context, undefined)\n            if (\n                error.name === 'BeforeHookError' ||\n                error.name === 'AfterHookError'\n            ) {\n                // make sure to return with a variable if before or after hook errors\n                return resolver.call(context)\n            }\n            throw error\n        }\n        this.runFinally(reversedHooks, context, variableDetails)\n        return variableDetails\n    }\n\n    private runBefore<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n    ) {\n        const contextCopy = { ...context }\n        try {\n            for (const hook of hooks) {\n                const newContext = hook.before(contextCopy)\n                if (newContext) {\n                    Object.assign(contextCopy, {\n                        ...contextCopy,\n                        ...newContext,\n                    })\n                }\n            }\n        } catch (error) {\n            this.logger?.error('Error running before hooks', error)\n            throw new BeforeHookError(error)\n        }\n        return contextCopy\n    }\n\n    private runAfter<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n        variableDetails: DVCVariable<T>,\n    ) {\n        try {\n            for (const hook of hooks) {\n                hook.after(context, variableDetails)\n            }\n        } catch (error) {\n            this.logger?.error('Error running after hooks', error)\n            throw new AfterHookError(error)\n        }\n    }\n\n    private runFinally<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n        variableDetails: DVCVariable<T> | undefined,\n    ) {\n        try {\n            for (const hook of hooks) {\n                hook.onFinally(context, variableDetails)\n            }\n        } catch (error) {\n            this.logger?.error('Error running finally hooks', error)\n        }\n    }\n\n    private runError<T extends DVCVariableValue>(\n        hooks: EvalHook[],\n        context: HookContext<T>,\n        error: Error,\n    ) {\n        try {\n            for (const hook of hooks) {\n                hook.error(context, error)\n            }\n        } catch (error) {\n            this.logger?.error('Error running error hooks', error)\n        }\n    }\n\n    enqueue(hook: EvalHook): void {\n        this.hooks.push(hook)\n    }\n}\n\nclass HooksRunnerError extends Error {\n    constructor(error: Error) {\n        super(error.message)\n        this.name = 'HooksRunnerError'\n        this.stack = error.stack\n    }\n}\n\nclass BeforeHookError extends Error {\n    constructor(error: Error) {\n        super(error.message)\n        this.name = 'BeforeHookError'\n        this.stack = error.stack\n    }\n}\n\nclass AfterHookError extends Error {\n    constructor(error: Error) {\n        super(error.message)\n        this.name = 'AfterHookError'\n        this.stack = error.stack\n    }\n}\n"]}